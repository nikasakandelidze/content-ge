# LeastCommonMultiple

პრობლემა:

```
მომხმარებელს შეჰყავს ორი რიცხვი თქვენმა პროგრამამ უნდა დაბეჭდოს ამ ორი რიცხვის
უმცირესი საერთო ჯერადი.
```

## პრობლემის გადაჭრის ხერხი:

პირველ რიგში მომხარებელმა უნდა შეიყვანოს ორი რიცხვი `readInt()` მეთოდით, რომლებსაც შევინახავთ ორ ცვლადში. თუ მომხმარებელმა შეიყვანა არასწორი რიცხვი, ვიძახებთ `readInt()` მეთოდს მანამ სანამ არ დავრწმუნდებით, რომ შეყვანილი რიცხვები დადებითია. ამის შემდეგ `findLcm()` მეთოდს ვიძახებთ და გადავცემთ მას ამ ორ ცვლადს. `findLcm()` მეთოდი აბრუნებს `int` ტიპის მნიშვნელობას, რომელსაც ვინახავთ `int result` ცვლადში. საბოლოოდ, კი ვბეჭდავთ `result`-ს, რაც არის შეყვანილი ორი რიცხვის უმცირესი საერთო ჯერადი.
რაც შეეხება იმას, თუ როგორ მოქმედებს `findLcm()` მეთოდი. ვინაიდან ვიცით, რომ ორი რიცხვის საერთო ჯერადი არის ამ ორი რიცხვის ნამრავლი, გადავუყვებით მაქსიმალური რიცხვიდან (`maxNum`) ამ ორი რიცხვის ნამრავლის ჩათვლით (`lastNum`) ყველა რიცხვს `for` ციკლით და შევამოწმებთ, თუ რომელი მათგანი გვაწყობს. შემოწმებას ვაკეთებთ შემდეგი მეთოდით `isCommonMultiple()`, რომელსაც გადაეცემა ამჟამინდელი `i`-ს მნიშვნელობა, ორივე რიცხვი და ვამოწმებთ `i`-ის მნიშვნელობა, თუ იყოფა უნაშთოდ ორივე რიცხვზე. როგორც კი ეს მეთოდი პირველჯერზევე დააბრუნებს `true`-ს, ვანიჭებს `res`-ს `i`-ს მნიშვნელობას და ვაბრუნებთ, სადაც სრულდება მეთოდი. თუ [`maxNum`, `lastNum`] ინტერვალში `isCommonMultiple()` მეთოდი არ შესრულდება, მაშინ ვიცით, რომ ამ ორი რიცხვის უმცირესი საერთო ჯერადი არის მათი ნამრავლი, რასაც ვინახავთ `lastNum` ცვლადში და ვაბრუნებთ მას.

## ალტერნატიული ამოხსნა:

არსებობს კავშირი უმცირეს საერთო ჯერადსა და უდიდეს საერთო გამყოფს შორის. ორი რიცხვის ნამრავლი უდრის უ.ს.გ.-ს და უ.ს.ჯ.-ს ნამრავლს, აქედან გამომდინარე უფრო ეფექტური იქნება უ.ს.გ (`gcd`) ვიპოვოთ ევკლიდეს ალგორთმით. შემდგომ მარტივად დავითვლით უ.ს.ჯ.-ს (`lcm`), რაც იქნება `lcm = firstNum * secondNum / gcd`. ევკლიდეს ალგორითმით კი `gcd` დაითვლება შემდენაირად:

```java
private int gcd(int a, int b) {
  int c;
  while (b != 0) {
    c = a % b;
    a = b;
    b = c;
  }
  return a;
}
```

## შენიშვნები:

- იტერირება აუცილებლად უნდა დავიწყოთ მაქსიმალური რიცხვიდან, ვინაიდან ეს ყველაზე მინიმალური მნიშვნელობა შეიძლება იყოს, რომელიც შეიძლება მიიღოს უმცირესმა საერთო ჯერადმა. ორი რიცხვს შორის უდიდესს ვინახავთ შემდეგი მოქმედებით: `int maxNum = Math.max(firstNum, secondNum);`.
- უმჯობესია `res` ცვლადს თავიდანვე მივანიჭოთ `lastNum`-ის მნიშვნელობა, ვინაიდან თუ `for` ციკლში გვიწერია `i < lastNum` ბოლო რიცხვზე აღარ შეამოწმებს და შესაძლოა არასწორი მნიშვნელობა დავაბრუნოთ.
- `isCommonMultiple()` მეთოდში გვჭირდება ორივე რიცხვზე სრულდებოდეს უნაშთო გაყოფა და არ უნდა დავწეროთ ან ოპერატორი (`||`) და ოპერატორის (`&&`) მაგივრად.
