## 1. რობოტი კარელი
რობოტი კარელი პატისმა შექმნა ბლაბლა

## 2. კარელის სამყარო
კარელი მარტივ სამყაროში ცხოვრობს. მისი სამყარო მართხკუთხა ფორმისაა, აქვს ქუჩები და გამზირები. ქუჩები განლაგებულია ჰორიზონტალურად - დასავლეთიდან აღმოსავლეთის მიმართულებით, გამზირები კი ვერტიკალურად სამხრეთიდან ჩრდილოეთის მიმართულებით. კარელი შეიძლება იდგეს ნებისმიერი ქუჩისა და გამზირის გადაკვეთაზე და იყურებოდეს ნებისმიერი მიმართულებით (აღმოსავლეთი, სამხრეთი, დასავლეთი, ჩრდილოეთი). სამყაროს მაგალითი შეგიძლია ქვევით იხილო. ამ მაგალითზე კარელი იმყოფება პირველი ქუჩის პირველ გამზირზე, ან სხვაგვარად რომ ვთქვათ (1,1) კოორდინატებზე.

![Karel World](/images/1_karel_world_1.png)

როგორც ხედავ, სამყაროში, კარელის გარდა, სხვა რაღაცეებიც არის. კარელის წინ არსებული ობიექტი არის ბრილიანტი. კარელს ხელები არ აქვს, ამიტომ ბრილიანტის აღმოჩენა შეუძლია მხოლოდ მაშინ, თუ ის იგივე ქუჩაზე და გამზირზეა, რომელზეც ბრილიანტია.
სამყაროში გვაქვს კედლებიც. კედელი კარელისთვის ბარიერს წარმოადგენს, რადგან მას არ შეუძლია კედელში გავლა, შესაბამისად, მას უნდა შემოუაროს.
კარელს ასევე აქვს ჩანთა, სადაც ბრილიანტები აქვს ჩალაგებული. ჩანთაში ნებისმიერი რაოდენობის ბრილიანტი შეიძლება იყოს. კარელის სამყარო ყოველთვის კედლებით არის შემოფარგლული, თუმცა, შეიძლება მას სხვადასხვა განზომილება ჰქონდეს, ბრილიანტები შეიძლება სხვადასხვა ადგილებში იდოს, კედლებიც შეიძლება სხვადასხვა ქუჩებზე და გამზირებზე გვქონდეს, იმის მიხედვით, თუ რა პრობლემის გადაჭრას ცდილობს კარელი.

![Karel World](/images/1_karel_world_2.png)

## 3. კარელის მეთოდები
კარელს გარკვეული ბრძანებების შესრულება შეუძლია, ესენია:
* **move** - ერთი ნაბიჯით წინ გადაადგილება. კარელი ვერ გადაადგილდება თუ მის წინ კედელია.
* **turnLeft** - მარცხნივ მოხვევა. კარელი მოტრიალდება მარცხნივ 90 გრადუსით.
* **pickBeeper** - ბრილიანტის აღება. კარელი ვერ აიღებს ბრილიანტს, თუ ბრილიანტი არ დევს იმავე ადგილზე, სადაც თვითონ კარელი იმყოფება.
* **putBeeper** - ბრილიანტის დადება. კარელი ვერ შეძლებს ბრილიანტის დადებას, თუკი მას ჩანთაში არ აქვს ბრილიანტი.

როგორც ქართულ ენას აქვს გრამატიკა და სინტაქსი ასევეა პროგრამირების ენებიც. გახსნილი და დახურული ფრჩხილები `()`  პროგრამირების ენა ჯავას სინტაქსის ელემენტია. მათი დაწერა აუცილებელია თუ გვინდა კარელმა ბრძანება შეასრულოს. პროგრამირების ენაზე ამას მეთოდს უწოდებენ. `move()`, `turnLeft()`, `pickBeeper()`, `putBeeper()` უკვე არსებული მეთოდებია, რომელთა შესრულებაც კარელს შეუძლია.

## 4. პირველი პროგრამა
მოდი პირველი პროგრამა დავწეროთ, ამისათვის უკვე თითქმის ყველაფერი იცი. წარმოიდგინე რომ კარელი სურათზე მოცემულ სამყაროში ცხოვრობს
![World before](./images/4_first_program_1.png)
შენი მიზანია დაწერო პროგრამა, რომლის გაშვების შემდეგაც კარელი აიღებს (2,1) კოორდინატებზე არსებულ ბრილიანტს და დადებს (4,2) კოორდინატებზე, თვითონ კი მივა (5,2) კოორდინატებზე და დაამთავრებს მუშაობას. პროგრამის დასრულების შემდეგ სამყარო ასე უნდა გამოიყურებოდეს:
![World after](./images/4_first_program_2.png)

ალბათ გასაგებია, რომ ამის შესრულება შეიძლება შემდეგი ბრძანებების მიმდევრობით

```java
move
pickBeeper
turnLeft
move
turnLeft
turnLeft
turnLeft
move
move
putBeeper
move
```

ეს ჯერ არ არის პროგრამა. ეს არის ადამიანისთვის გასაგებ ენაზე დაწერილი ინსტრუქცია, რომელიც ამოცანას ჭრის. ამას სხვაგვარად ალგორითმი ჰქვია. ცხადია, იმისათვის, რომ ამოცანა გადაჭრა ალგორითმი უნდა იცოდე, თუმცა ეს საკმარისი არ არის. პროგრამა კარელისთვის გასაგებ ენაზე უნდა ეწეროს ამისათვის თითოეული ბრძანება უნდა გადავაკეთოთ მეთოდად, ანუ ბრძანებებს მივუმატოთ `();`. მივიღებთ

```java
move();
pickBeeper();
turnLeft();
move();
turnLeft();
turnLeft();
turnLeft();
move();
move();
putBeeper();
move();
```

ესეც არ არის გამართული პროგრამა. იმისათვის, რომ კარელმა ეს მეთოდები შეასრულოს მან უნდა იცოდეს საიდან უნდა დაიწყოს მეთოდების შესრულება. ამისათვის არსებობს სპეციალური `run` მეთოდი. ის არის პროგრამის დასაწყისი. ყველა პროგრამა `run` მეთოდით იწყება. იგი შემდეგნაირად გამოიყურება

```java
public void run() {
    move();
    pickBeeper();
    turnLeft();
    move();
    turnLeft();
    turnLeft();
    turnLeft();
    move();
    move();
    putBeeper();
    move();
}
```
ყურადღება მიაქციეთ გახსნილ და დახურულ ფიგურულ ფრჩხილებს, ისინი აღნიშნავენ `run` მეთოდის დასაწყისს და ბოლოს. იმისათვის, რომ ადამიანისთვის მარტივი დასანახი იყოს თუ რა მეთოდებია `run`-ის შიგნით, თითოეული მეთოდი შეწეულია `tab`-ით. `tab`-ებს და სხვა "თეთრ სიმბოლოებს"(space, enter, ...) არანაირი დატვირთვა არ აქვს და პროგრამის მიმდინარეობას არ ცვლის. მათ იყენებენ მხოლოდ იმისათვის, რომ ადამიანისთვის იყოს კოდი მარტივად დასანახი და გასაგები. თუ რას ნიშნავს `public void` შეგვიძლია ამ ეტაპზე დავიკიდოთ.

აი მიუთითე საიდან დაიწყოს კარელმა ბრძანებების შესრულება, მაგრამ ეს ჯერ ისევ არ არის გამართული პროგრამა. ჯერ პროგრამაში არსად გიხსენებია კარელი. სადღაც ხომ უნდა თქვა, რომ კარელის მოძრაობას აპირებ. ამისათვის უნდა შექმნა კლასი რომელიც `Karel`-ს "ავრცობს".

```java
public class FirstProgram extends Karel {
    public void run() {
        move();
        pickBeeper();
        turnLeft();
        move();
        turnLeft();
        turnLeft();
        turnLeft();
        move();
        move();
        putBeeper();
        move();
    }
}
```

ამ კოდში `FirstProgram` არის შენი პროგრამის სახელი. ისევ მიაქციე ყურადღბა გახსნილ და დახურულ ფიგურულ ფრჩხილს. `run` მეთოდი კლასის შიგნით უნდა იყოს.

```java
public class FirstProgram extends Karel {
    ...
}
```
კოდის ეს ნაწილი აღნიშნავს იმას, რომ შენ კარელის მოძრაობის სურვილი გაქვს. `FirstProgram`  შენი პროგრამის სახელია. ამის შემდეგ უკვე შეგიძლია თავისუფლად გამოიყენო მეთოდები `move()`, `pickBeeper()` და ა.შ. 

ეს კოდი ჯერ კიდევ არ არის საბოლოო ვერსია. რადგან შენ ჯერ კიდევ არ მიგითითებია `Karel`-ს რომ იყენებ, სადაური კარელია? ვინ შექმნა? საიდან მოვიდა? ამისათვის უნდა დაწერო შემდეგი კოდი
``` java
import stanford.karel.*;
```

სულ ეს არის. როგორც იქნა პირველი პროგრამა დავწერეთ! საბოლოო კოდი შემდეგნაირად გამოიყურება
```java
import stanford.karel.*;

public class FirstProgram extends Karel {
    public void run() {
        move();
        pickBeeper();
        turnLeft();
        move();
        turnLeft();
        turnLeft();
        turnLeft();
        move();
        move();
        putBeeper();
        move();
    }
}
```

## 5. პირველი პროგრამის გაშვება
აბა გაუშვი და შეამოწმე. ამისათვის ეკლიპსში, კარელის პორექტში, შექმენი `FirstProgram.java`(გაითვალისწინე, რომ ფაილის სახელი და პროგრამის სახელი ერთიდაიგივე უნდა იყოს). ჩააკოპირე პირველი პროგრამის კოდი ამ ფაილში, შემდეგ კი დააკლიკე პროგრამის გაშვების ღილაკს

![Run program](./images/5_run_first_program_1.png)

მარცხენა ღილაკი ბოლოს გაშვებულ პროგრამას გაუშვებს, მარჯვენა ღილაკი კი პროგრამის არჩევის საშუალებას მოგცემს.

გაეშვა? მუშაობს? **ყოჩაღ! შენ უკვე პროგრამისტი ხარ!**

## 6. პროგრამის შაბლონი
კონკრეტულად რას ნიშნავს `public`, `class`, `extends`, `void`, `import` ამ ეტაპზე დაიკიდე. ამ საკითხებს კიდევ მივუბრუნდებით. მნიშვნელოვანი რაც არის და რაც უნდა დაიმახსოვრო არის შემდეგი კოდი:

```java
import stanford.karel.*;

public class NameYourProgram extends Karel {
    public void run() {
        ...
    }
}
```

ეს არის საწყისი პროგრამის შაბლონი. ფაილის სახელი უნდა ემთხვეოდეს შენი პროგრამის სახელს(ამ მაგალითში შენი პროგრამის სახელია `NameYourProgram`). კოდი უნდა დაწერო `run` მეთოდის შიგნით.

## 7. ალგორითმი
მოდი გავიმეოროთ, რა არის ალგორითმი? ალგორითმი არის ამოცანის გადაჭრისთვის საჭირო ინსტრუქციების მიმდევრობა, რომელიც ადამიანისთვის გასაგებ ენაზეა დაწერილი. იმისათვის, რომ ალგორითმიდან გამართული და მუშა პროგრამა მიიღო კოდის დაწერა მოგიწევს.

არსებობს კარგი და ცუდი ალგორითმები. აქ გარჩეული ამოცანის გადაჭრა შეგვეძლო განსხვავებული  ალგორითმითაც. მაგალითად სანამ ბრილიანტს აიღებს, კარელმა შეიძლება მთელი სამყარო შემოიაროს, მხოლოდ შემდეგ აიღოს ბრილიანტი და დადოს მითითებულ ადგილას. ეს ალგორითმიც ამოცანას გადაჭრის, თუმცა, ამისათვის კარელს გაცილებით მეტი სიარული მოუწევს. შესაბამისად, ალგორითმები შეგიძლია ერთმანეთს შეადარო იმის მიხედვით, თუ რომელი უფრო მეტ "ენეგიას" და დროს ხარჯავს. ცხადია, ჯობია ისეთი ალგორითმით გააკეთო საქმე, რომლითაც დანახარჯი ნაკლები იქნება.

## 8. ახალი მეთოდები
თურმე კარელს არსებული ბრძანებების გარდა შეიძლება ახალი ბრძანებებიც ასწავლო. ამ ეტაპზე კარელმა, როგორც სოციალისტური შრომის გმირმა იცის მხოლოდ მარცხნივ მოხვევა. ამიტომ, კარგი იქნება, თუ გაუფართოებ ცოდნას და მარჯვნივ მოხვევასაც ასწავლი. ამისათვის, უნდა აღწერო ახალი მეთოდი. უკლებლივ ყველა მეთოდის აღწერა ორი ნაწილისგან შედგება მეთოდის თავი, სადაც მეთოდის სახელი იწერება და მეტოდის ტანი, სადაც იწერება თუ რა უნდა გააკეთოს კარელმა ამ მეთოდის გამოძახების შემდეგ. მეთოდის თავის შემდეგ იწერება გახსნილი ფიგურული ფრჩხილი `{`, შემდეგ მეთოდის ტანი და შემდეგ დახურული ფიგურული ფრჩხილი `}`. იმისათვის, რომ ადამიანისთვის უფრო გასაგები იყოს მეთოდი რას აკეთებს მეთოდის ტანი შეწეულია ხოლმე ტაბებით. როგორც აქამდე გითხარი ტაბებს არანაირი დატვირთვა არ აქვს პროგრამის მუშაობაში, რომც არ ეწეროს, პროგრამა მაინც იმუშავებს, თუმცა კოდი ლამაზი არ იქნება. გასაგებია, რომ სილამაზე სუბიექტური თემაა, მაგრამ მეთოდის ტანის ტაბებით გამოყოფა მიღებული პრაქტიკაა და მოდი შენც ასე წერე ხოლმე. 

მარჯვნივ მოხვევის მეთოდი შემდეგნაირად გამოიყურება

```java
private void turnRight() {
    turnLeft();
    turnLeft();
    turnLeft();
}
```

ამ კოდში `private void turnRight()` მეთოდის თავია. მეთოდის თავი შედგება მეთოდის თვისებების აღწერისგან, ესენია `private` და `void`, და ასევე მეთოდის სახელისგან `turnRight`. მეთოდის თვისებები შეგიძლია ცოტა ხნით დაიკიდო, ამას მალე მიუბრუნდები. მეთოდის სახელს რაც შეეხება - სახელად, ცხადია, ნებისმიერი სხვა რამ შეგეძლო შეგერჩია მაგალითად `moukhvieMarjvniv` ან `marjvnisaken` თუმცა სტილისტურად `turnRight` უფრო ემთხვევა სხვა მეთოდების სახელებს და ამიტომაც სხვებს ეს სჯობს. სახელის შემდეგ გახსნილი და დახურული ფრჩხილიც `()` აუცილებელია და ესევ მეთოდის თავში შედის.

თუკი წინა მაგალითში  მარჯვნივ მოხვევის მეთოდს გამოიყენებ ასეთ კოდს მიიღებ:

```java
import stanford.karel.*;

public class FirstProgram extends Karel {
    public void run() {
        move();
        pickBeeper();
        turnLeft();
        move();
        turnRight();
        move();
        move();
        putBeeper();
        move();
    }

    private void turnRight() {
        turnLeft();
        turnLeft();
        turnLeft();
    }
}
```

მეთოდი აუცილებლად კლასის შიგნით უნდა ეწეროს და სხვა მეთოდების გარეთ. ამ შემთხვევაში ჩვენს `FirstProgram` კლასში 2 მეთოდი წერია `run` მეთოდი და `turnRight` მეთოდი. ყურადღებას თუ მიაქცევ `public void run()`-იც ჩვეულებრივი მეთოდია, უბრალოდ ცოტა განსხვავებული თვისებები აქვს და სხვა ყველა დანარჩენი მეთოდებისგან იმით განსხვავდება, რომ `run` მეთოდი აუცილებლად პირველი სრულდება, მეტიც თუკი პროგრამაში `run` მეთოდს არ დაწერ პროგრამა არაფერსაც არ გააკეთებს. მეთოდების მიმდევრობას არანაირი მნიშვენლობა არ აქვს. მაგალითად ჯერ შეიძლება `turnRight` მეთოდი ეწეროს და მერე `run` ან პირიქით.

### რას აკეთებს კარელი ამ პროგრამის შესრულების დროს?
კარელი პროგრამის გაშვების შემდეგ პირველ რიგში ეძებს `run` მეთოდს და იწყებს `run` მეთოდში არსებული ბრძანებების შესრულებას. პირველი ბრძანება არის `move()`, შესაბამისად კარელი გადაადგილდება ერთი ნაბიჯით წინ, შემდეგ `pickBeeper` - კარელი აიღებს ბრილიანტს, შემდეგ `turnLeft` - მოტრიალდება მარცხნივ, `move` - გადაადგილდება ერთი ნაბიჯით წინ, შემდეგ შეხვდება ბრძანება `turnRight` კარელმა ეს ბრძანება ავტომატურად არ იცის, ეს რაღაც ახალი ბრძანებაა, დაიწყებს ამ ბრძანების ძებნას კოდში, მიაგნებს `turnRight` მეთოდის განმარტებას და დაიწყებს მის შესრულებას, შესაბამისად გააკეთებს `turnLeft` - მოტრიალდება მარცხნივ, მერე `turnLeft` - მოტრიალდება მარცხნივ და ისევ `turnLeft` - მოტრიალდება მარცხნივ. ამით `turnRight` მეთოდის ბრძანებები ამოიწურა, შესაბამისად `turnRight` მეთოდი დასრულდება(სრულად შესრულდება) და კარელი გააგრძელებს `run` მეთოდში დაწერილი მორიგი ბრძანების შესრულებას. ანუ შემდეგი ბრძანება იქნება `move` - კარელი წავა წინ, `move` - ისევ წინ, `putBeeper` - დადებს ბრილიანტს, `move` - ისევ წინ. ახლა უკვე კარელმა `run` მეთოდში აღწერილი ყველა ბრძანება შეასრულა(მიმდევრობით) და `run` მეთოდი მთავრდება რაც ნიშნავს, რომ პროგრამაც ასრულებს მუშაობას.

## 9. რაში გვჭირდება ახალი მეთოდები
მეთოდების შექმნის რამდენიმე მიზეზია.
1. შეგვიძლია მეთოდი ერთხელ შევქმნათ და ბევრჯერ გამოვიყენოთ. წინააღმდეგ შემთხვევაში სხვადასხვა ადგილებში ერთიდაიგივე კოდის დაწერა მოგვიწევს. კოდის გამეორება კიდე ძალიან ცუდი პრაქტიკაა, რადგან ერთ ადგილას ცვლილების დროს ყველა გამეორებულ ადგილასაც უნდა გააკეთო ცვლილება, რაც შრომატევადია და თან თუ გამოგრჩება რომელიმე ადგილი შეცდომას გამოიწვევს.
2. ახალი მეთოდების შექმნით კოდი ბევრად უფრო გასაგები გამოდის და გასაგებად იკითხება.
3. მეთოდი შეგიძლია ჩათვალო შავ ყუთად, მაგალითად იცი, რომ `turnRight` მეთოდის გამოძახების შემდეგ კარელი მოუხვევს მარჯვნივ და თუ როგორ გააკეთებს ამას შეიძლება იმაზე არ ინერვიულო.

## 10. FOR ციკლი
ხშირად არის სიტუაცია, როდესაც გინდა ბრძანებების რაღაც მიმდევრობა რამდენჯერმე გაიმეორო. იმის მაგივრად, რომ copy/paste გააკეთო შეგიძლია for ციკლი გამოიყენო.

კოდის გამეორება და copy/paste ძალიან ცუდი იდეაა პროგრამის წერის დროს. ამ დროს პროგრამაში ჩნდება ორ ან უფრო მეტ ადგილზე ერთიდაიგივე კოდი. კოდის გამეორება არ არის სასურველი, ერთი იმიტომ, რომ ზედმეტია და არ არის საჭირო, მეორე იმიტომ რომ შეცდომების წყაროა. როდესაც ერთიდაიგივე კოდი 10-ჯერ გაქვს გადაკოპირებული და აღმოჩნდა, რომ ეს კოდი შესაცვლელია. უნდა ჩამოუარო ათივე ადგილს და ყველგან შეცვალო. თუკი რომელიმე ადგილი დაგავიწყდა, პროგრამა აღარ იქნება გამართული. იმ შემთხვევაში კი, როდესაც კოდის გამეორება არ გაქვს ცვლილებებიც მარტივი შესატანია და შეცდომებსაც არ იწვევს. 

მივუბრუნდეთ for ციკლს. დავუშვათ, კარელი 100 სიგრძის სამყაროში ცხოვრობს, ახლა არის პირველი გამზირის პირველ ქუჩაზე, ანუ (1,1) კოორდინატებზე და უნდა აიღოს ბრილიანტი, რომელიც მდებარეობს მეასე გამზირის პირველ ქუჩაზე, ანუ (100,1) კოორდინატებზე.  რა უნდა ამის გაკეთებას `move();`-ს დაწერ 99-ჯერ მერე ერთ `pickBeeper();`-ს და ეგაა მთელი პროგრამა. მაგრამ 100-ჯერ `move();`-ის კოპირება კაი შრომატევადი საქმეა. 10000 სიგრძის სამყარო რომ იყოს? ან რომ გამოგრჩეს ერთი `move();` ან ზედმეტი დავწერო? მოკლედ საწვალებელია. თუმცა კარგი ამბავი ის არის, რომ არსებობს სპეციალური ინსტრუქცია - `for ციკლი` რომელიც საშუალებას მოგცემს ერთი ინსტრუქცია ან ინსტრუქციების მიმდევრობა იმდენჯერ გაიმეორო რამდენჯერაც გინდა. 

```java
for (int i = 0; i < რაოდენობა; i++) {
    ბრძანებები რომელთა გამეორებაც გვინდა
}
```

`for ციკლი`, ისევე როგორც მეთოდი, შედგება ორი ნაწილისგან. `for ციკლის` თავისგან და `for ციკლის` ტანისგან. `for ციკლის` თავში ერთადერთი რისი შეცლვაც შეგიძლია არის `რაოდენობა`, რომელიც აღნიშნავს თუ რამდენჯერ გინდა გაიმეორო `for ციკლის` ტანში არსებული ინსტრუქციების მიმდევრობა. კოდის დანარჩენი ნაწილი შეუცვლელი დატოვე, თუ რას ნიშნავს ეს `int i = 0; ...` ცოტა ხნით დავიკიდოთ. მთავარი ის არის, რომ რა რიცხვსაც რაოდენობის მაგივრად ჩაწერ(და უნდა ჩაწერო რამე ნატურალური რიცხვი), იმდენჯერ გამეორდება მეთოდის ტანში არსებული ინსტრუქტიცები. მეთოდის მსგავსად `for ციკლის` ტანში დაწერილი ინსტრუქციები იწერება გახსნილ ფიგურულ ფრჩხილსა და დახურულ ფიგურულ ფრჩხილს შორის და იმისათვის, რომ ადამიანისთვის მარტივად აღსაქმელი იყოს "შეწეულია" `tab`-ებით. მაგალითად ამოცანის ამოხსნა შემდეგი კოდით არის შესაძლებელი:

```java
import stanford.karel.*;

public class ForExample extends Karel {
    public void run() {
        for (int i = 0; i < 99; i++) {
            move();
        }
        pickBeeper();
    }
}
```

რა თქმა უნდა, for ციკლის ტანში შეიძლება არა ერთი, არამედ რამდენიმე ინსტრუქცია/ბრძანება ეწეროს. ამ შემთხვევაში არსებული ინსტრუქციები მეორდება მიმდევრობით (თითქოს ეს ინსტრუქციები ერთმანეთის ქვეშ დააკოპირეს). მაგალითად კოდი

```java
for (int i = 0; i < 4; i++) {
    move();
    turnLeft();
}
```
ნიშნავს არა იმას, რომ კარელმა ჯერ ოთხი `move()` უნდა შეასრულოს და შემდეგ 4 `turnLeft()`, არამედ ნიშანავს, ჯერ შეასრულოს `move()` მერე `turnLeft()` და ეს გაიმეოროს 4-ჯერ. რის შედეგადაც კარელი საწყის წერტილზე დაბრუნდება, თუკი ირგვლივ კედლები არ არის.

## while ციკლი
`for ციკლის` გამოყენება კარგია მაშინ, როდესაც გარკვეული ბრძანებების მიმდევრობის გამეორება გინდა და იცი, რამდენჯერ გინდა გაიმეორო. ამ დროს ბრძანებების მიმდევრობას წერ `for ციკლის` ტანში, `for ციკლის` თავში უთითებ რაოდენობას (კონკრეტულ რიცხვს), თუ რამდენჯერ გინდა გამეორება. ხშირად არის სიტუაცია, როდესაც რაღაცის გამეორება გინდა, მაგრამ ზუსტად არ იცი რამდენჯერ. ამ შემთხვევაში გამოგადგება `while ციკლი`. მაგრამ სანამ `while ციკლამდე` მიხვიდოდე, ჯერ სასწავლი გაქვს “პირობები”. კარელს თავისი სამყაროს შესახებ გარკვეული პირობების გაგება შეუძლია, მაგალითად, შეუძლია გაიგოს მის წინ არის თუ არა კედელი, აქვს თუ არა ბრილიანტები ჩანთაში, დგას თუ არა ბრილიანტზე და ა.შ. მაგალითად:

* `frontIsClear()` - ამოწმებს არის თუ არა მის წინ სიცარიელე
* `beepersPresent()` - ამოწმებს არის თუ არა ბრილიანტი იქ სადაც თვითონ დგას
* `beepersInBag()` - აქვს თუ არა ბრილიანტები ჩანთაში

წარმოიდგინე, რომ კარელი პირველი გამზირის პირველ ქუჩაზე იმყოფება, ხოლო ბრილიანტი - ბოლო გამზირის პირველ ქუჩაზე და კარელს უნდა ამ ბურთის აღება. კარელმა არ იცის რამხელაა სამყარო და რამდენი გამზირია მასში. გასაგებია, რომ პირველი ქუჩის ბოლოში მისასვლელად `move() ` ბრძანება უნდა გაიმეორო რამდენჯერმე. თუმცა პრობლემა იმაშია, რომ არ იცი ზუსტად რამდენჯერ. შესაბამისად, `for ციკლი` ამაში არ გამოგადგება(გაიხსენე, რომ `for ციკლს` კონკრეტული რიცხვი უნდა მიუთითო, რომელიც ახლა არ იცი). თუმცა, აქვეა `while ციკლი`, რომელიც `for ციკლის` მსგავსად თავისა და ტანისგან შედგება. `while ციკლის` ტანში უნდა ჩავწერო ბრძანებების მიმდევრობა, რომელთა გამეორებაც გინდა(ისევე, როგორც `for ციკლის` შემთხვევაში). `while ციკლის` თავში კი უნდა ჩაწერო პირობა, რის შედეგადაც `while ციკლი` გაიმეორებს ბრძანებების მიმდევრობას **მანამ , სანამ** პირობა სრულდება. `while ციკლის` ზოგადი ჩანაწერი ასეთია:

```java
while (პირობა) {
    ბრძანებები რომელთა გამეორებაც გვინდა
}
```
ეს ნიშნავს გაიმეორე ბრძანებების მიმდევრობა, რომელიც `while ციკლის` ტანში წერია, მანამ სანამ `while ციკლის` თავში დაწერილი პირობა სრულდება.
კარელი თავდაპირველად შეამოწმებს `while ციკლის` თავში დაწერილ პირობას თუკი პირობა სრულდება მაშინ ის შეასრულებს ბრძანებების მიმდევრობას, რომელიც `while ციკლის` ტანში წერია. ამის შემდეგ კარელი ისევ შეამოწმებს პირეობას, თუ პირობა კვლავ სრულდება, კარელი შეასრულებს ტანში დაწერილ ბრძანებებს და ა.შ. თუკი პირობა შესრულდა მაშინ ციკლი დამთავრდება და კარელი გააგრძელებს ციკლის ქვემოთ არსებული ბრძანებების შესრულებას.


მაგალითად შემდეგი კოდის შემთხვევაში

```java
while (frontIsClear()) {
    move();
}
```

კარელი იმოძრავებს მანამ, სანამ მის წინ სიცარიელეა. შესაბამისად, იმოძრავებს მანამ, სანამ მის წინ კედელი არ იქნება, ანუ მიაღწევს პირველი ქუჩის ბოლოში.

## 12. არასწორი while ციკლი
ყურადღება მიაქციე იმ ფაქტს, რომ თუ პირობა სრულდება კარელი ყველა ბრძანებას შეასრულებს რომელიც ციკლის ტანში წერია, მიუხედავად იმისა, ამ ბრძანებების პროცესში მითითებული პირობა ირღვევა თუ არა. კარელი პირობას მხოლოდ დასაწყისში ამოწმებს, ბრძანაბების შუაში პირობა არ მოწმდება. შესაბამისად შემდეგი კოდი:

```java
while (frontIsClear()) {
    move();
    move();
}
```

შეიძლება დაიქრეშოს თუკი კარელს კედლამდე კენტი რაოდენობის ნაბიჯი დარჩა. რადგან ყოველ ჯერზე ის ორ-ორ ნაბიჯს დგამს ხოლმე(ნაბიჯსა და ნაბიჯს შორის არ ამოწმებს).

## 13. if ოპერატორი
ხანდახან არის მომენტი, როდესაც რაღაც პირობის შემოწმება გირდება ხოლმე ერთხელ და არა მრავალჯერ, ისე როგორც `while ციკლშია`. ამ დროს გამოგადგება `if ოპერატორი`, რომელიც `for`-ის და `while`-ის მსგავსად შედგება თავისა და ტანისაგან. `if`-ის თავში შეგიძლია ჩაწერო ნებისმიერი პირობა, ხოლო მის ტანში ინსტრუქტიცების ნებისმიერი მიმდევრობა, შესაბამისად, თუ პირობა სრულდება, მაშინ კარელი შეასრულებს `if`-ის ტანში ჩამოწერილ ბრძანებებს, თუ პირობა არ სრულდება მაშინ არ შეასრულებს. `for`-ის და `while`-ის მსგავსად  `if`-ის ტანი გამოყოფილია გახსნილი და დახურული ფიგურული ფრჩხილებით `{}`  

მაგალითად შემდეგი კოდის შემთხვევაში
```java
if (beepersPresent()) {
    pickBeeper();
}
move();
```

კარელი შეამოწმებს და თუკი ბრილიანტზე დგას, მაშინ მას აიღებს (`if` დამთავრდება) და შემდეგ წინ გადაადგილდება, ხოლო თუკი ბრილიანტზე არ დგას, მაშინ `if`-ის ტანში არსებულ ბრძანებებს საერთოდ არ შეასრულებს და უბრალოდ გადაადგილდება.

## 14. if/else 
`if ოპერატორს` გააჩნია `else` – "თუ არა" ბლოკიც, რომლის საშუალებითაც შეგიძლია შემდეგი ტიპის ლოგიკა განავითარო - თუკი კარელი ბრილიანტზე დგას, მაშინ აიღოს ის, ხოლო **თუ არა**, მაშინ დადოს ბრილიანტი. კოდი შემდეგნაირად დაიწერება:
```java
if (beepersPresent()) {
    pickBeeper();
} else {
    putBeeper();
}
```

`if ოპერატორს` `else` ბლოკი შეიძლება ჰქონდეს, შეიძლება არა, ანუ, შეგიძლია დაუწერო, შეგიძლია არ დაუწერო. გასათვალისწინებელია, რომ ნებისმიერ შემთხვევაში შესრულდება ან `if ბლოკში` არსებული ბრძანებები(თუკი პირობა ჭეშმარიტია) ან `else ბლოკში` არსებული ბრძანებები(თუკი პირობა მცდარია). ამასთან ერთ-ერთი ბლოკი აუცილებლად შესრულდება(რადგან პირობა ან ჭეშმარიტი იქნება, ან მცდარი) და ორივე ვერასდროს შესრულდება.

## 15. ოპერატორების ერთმანეთში ჩადგმა
თურმე შესაძლებელია `for`, `while` და `if` ერთმანეთში "ჩადგა" როგორც გინდა. ანუ შესაძლებელია, რომ `for ციკლის` ტანში იყოს `while`, რომლის ტანშიც იქნება `if`, რომლის ტანშიც იქნება ისევ `for` და ა.შ. როგორც მოგინდება. წარმოიდგინე, რომ სამყაროში პირველ ქუჩაზე სხვადასხვა ადგილებში მაქსიმუმ ერთი ბრილიანტი დევს (ზოგიერთ უჯრაზე შეიძლება საერთოდაც არ იდოს ბრილიანტი) და გინდა, რომ კარელმა ყველა ბრილიანტი აიღოს.

![ოპერატორების ერთმანეთში ჩადგმა](./images/15_nested_operators_1.png)

ამის გაკეთება შესაძლებელია შემდეგი კოდით.

```java
import stanford.karel.*;

public class IfWhileExample extends Karel {
    public void run() {
        while (frontIsClear()) {
            if (beepersPresent()) {
                pickBeeper();
            }
            move();
        }
        if (beepersPresent()) {
            pickBeeper();
        }
    }
}